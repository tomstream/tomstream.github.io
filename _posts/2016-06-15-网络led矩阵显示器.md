---
layout: post
title: 网络LED矩阵显示器
---

这篇文章的目的是掌握Linux网络程序和多线程程序的编写，实现一个网络访问的LED矩阵显示器。

## 目的

1. 复习socket编程（网络原理课）；
2. 实现一个网络访问的LED矩阵显示器。

## 步骤
### 连线图
首先按照图示方式进行连线：

![rpi－max7219连线图](http://7xljx0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87dd%201.png?imageView/2/w/300/q/90)
### 字符显示
对于字符串的显示我采用在应用程序进行循环写入的方法。
首先编写一个显示函数，传入值个字符串，每500ms之后，写入一个字符，直到字符串的末尾。
	
	//Display a string on the MAX7219
	int print_str_on_MAX7219(char str[])
	{
	    int fd; 
	    int ret; 
	
	    fd = open("/dev/MAX7219", O_WRONLY);  
	    if (fd < 0) 
	    {  
	        fprintf(stderr, "Fail to open /dev/MAX7219!\n");
	        return -1;
	    }
	    int i=0;
	    while(str[i])
	    {
	        if((ret = write(fd, &str[i], 1))<0)
	        {
	            fprintf(stderr, "Fail to write /dev/MAX7219! %d\n", ret);
	            return -1;
	        }
	        ++i;
	        Delay_xms(500);
	    }
	    fprintf(stdout, "Write /dev/MAX7219 successfully! %d\n", ret);
	    close(fd);
	    return 0;
	}
	
### Socket程序编写
### 服务端
Socket程序的编写和计网的实验原理基本相同。对于实现多个客户端的连接可以采用了IO复用的方式来处理。

首先在主程序建立服务端Socket连接，其过程如下：

![](http://7xljx0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%871122.png?imageView/2/w/500/q/90)

	int listenfd;
	struct sockaddr_in  servaddr;    
	//create a socket
	if((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
	{
	    fprintf(stderr, "Create socket error: %s(errno: %d)\n", strerror(errno), errno);
	    exit(0);
	}
	else
	    fprintf(stdout, "Create a socket\n");   
	    
	//set the server address
	memset(&servaddr, 0, sizeof(servaddr));  //initialize the server address 
	servaddr.sin_family = AF_INET;           //AF_INET means using TCP protocol
	   servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    //any in address(there may more thaonenetwork card in the server)
	servaddr.sin_port = htons(PORT);            //set the port 
	  
	//bind the server address with the socket
	if(bind(listenfd, (struct sockaddr*)(&servaddr), sizeof(servaddr)) == -1)
	{
	     fprintf(stderr, "Bind socket error: %s(errno: %d)\n", strerror(errno), errno);
	     exit(0);
	}
	else
	puts("Bind\n");   
	
	//listen
	if(listen(listenfd, BACKLOG) == -1)
	{
	    fprintf(stderr, "Listen socket error: %s(errno: %d)\n", strerror(errno), errno);
	    exit(0);
	}
	else
	    puts("Listen\n");
	    
首先调用socket函数建立一个socket，其中传入的参数AF_INET参数表示其采用TCP协议，并且调用Linux系统提供的fcntl函数设置这个socket为非阻塞。

然后初始化服务的地址，保护监听的IP（这里设置的监听服务器端所有的网卡），设置相应的端口以及协议类型（TCP），调用bind函数将其和前面的建立的socket绑定。

设置该socket开始监听，这主要对应TCP连接上面的第一次握手，将TCP第一次握手成功的放在队列（SYN队列）中，其中传入的参数BACKLOG为Socket中队列的长度。

然后调用Accept函数进行接收客户端的请求，其主要是从TCP上次握手成功的Accept队列中将客户端信息去除进行处理。

接下来使用select函数进行并发：

	while(true){
			// //clear socket set
			FD_ZERO(&readables);
	
			//add server socket to set
			FD_SET(server, &readables);
			//add connected clients sockets
			for (auto iter:clients)
			{
				int client = iter.first;
				FD_SET(client, &readables);
			}
			//select
			if(clients.size()>0)
				max_sd = max(server, clients.rbegin()->first);
			else
				max_sd = server;
			int retval = select(max_sd+1, &readables, NULL, NULL, NULL);
			if (retval < 0)
			{
				perror("select");
				return 1;
			}
			//if server is readable, new client comes
			if (FD_ISSET(server, &readables))
			{
				int new_socket;
				//accept new client
				if ((new_socket=accept(server, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0)
				{
					perror("accpet");
					return 1;
				}
				printf("Accept\n");
				
				//add it to client data set
				clients.insert(pair<int,ClientData>(new_socket, ClientData(inet_ntoa(address.sin_addr), ntohs(address.sin_port))));
			}
	
			//if client is readable, read message
			vector<int> exit_clients;
			for (auto iter:clients)
			{
				int client = iter.first;
				if (FD_ISSET(client, &readables))
				{
					//check if it is closed
					int valread = read(client, data, 1024);
					if(valread == 0){
						//nothing read, it means client close connection
						getpeername(client, (struct sockaddr*)&address, (socklen_t*)&addrlen);
						inet_ntoa(address.sin_addr));
	
						//close socket and erase it from client set
						close(client);
						//clients.erase(client); don't erase immediately
						exit_clients.push_back(client);
					}
					else{
						//read message from client
						puts("---------------------------");
						printf("Receive message from client no.%d : %s", client, data);
	
						data[valread]='\0';//add end character
						//print str
	                    print_str_on_MAX7219(data);
	                    puts("Write\n");
	                }
				}
			}
			//delete exit clients
			for(int client:exit_clients)
				clients.erase(client);
		}

### 客户端
客户端的基本流程如下：

![](http://7xljx0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%871232311.png?imageView/2/w/500/q/90)

	void clientManager(void* argv)
	{
	    ClientInfo *client = (ClientInfo *)(argv);
	    
	    BYTE buff[BUFFSIZE];
	    int recvbytes;
	    
	    int i=0;
	    int clientfd = client->clientfd;
	    struct sockaddr_in addr = client->addr;
	    int isConn = client->isConn;
	    int clientIndex = client->index;
	    //receive the string sent from the client
	    while((recvbytes = recv(clientfd, buff, BUFFSIZE, 0)) != -1)
	    {
	         buff[recvbytes] = '\0';
	         pthread_mutex_lock(&writeMutex);
	         Display(buff);
	         pthread_mutex_unlock(&writeMutex);
	    }   //end while
	    
	    pthread_mutex_lock(&clientsMutex[clientIndex]);
	    client->isConn = 0;
	    pthread_mutex_unlock(&clientsMutex[clientIndex]);
	    pthread_cond_signal(&connDis);  //send a disconnetion signal and the waiting client can get response  
	    if(close(clientfd) == -1)
	        fprintf(stderr, "Close %d client eroor: %s(errno: %d)\n", clientfd, strerror(errno), errno);
	    fprintf(stderr, "Client %d connetion is closed\n", clientfd);
	    
	    pthread_exit(NULL);
	}	
	
### Telnet连接显示

将程序在树莓派上编译之后运行，可以看到服务器端的socket创建，绑定以及监听成功。然后在pc终端用telnet进行连接：

树莓派端的终端：

	pi@raspberrypi:~ $ sudo ./a.out
	Create a socket 
	Bind 
	Listen
	Accept
	Write 
	Accept
	Write

pc端终端1：

	➜  ~ git:(master) ✗ telnet 10.110.28.25 8888
	Trying 10.110.28.25...
	Connected to 10.110.28.25
	Escape character is '^]'
	I am 1

pc端终端2：
	
	➜  ~ git:(master) ✗ telnet 10.110.28.25 8888
	Trying 10.110.28.25...
	Connected to 10.110.28.25
	Escape character is '^]'
	I am 2
	
可以看到服务端接受了两个客户端的连接，然后在两个客户端分别发送字符串，发现其字符串分别在MAX7219上依次正常显示。

