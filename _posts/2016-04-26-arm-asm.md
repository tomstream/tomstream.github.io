---
layout: post
title: 使用stm32实现自行车码表

---



---

## 目的
1. 理解MCU上电启动过程；
2. 掌握使用Cube库来编写STM32裸机程序的方法；
3. 掌握使用Cube库来编写GPIO和UART程序的方法；
4. 掌握使用Cube库来编写中断响应程序的方法；
5. 理解前后台程序模式；
6. 掌握在STM32F103上编写裸机程序并下载运行的方法。

## 器材

### 硬件

* STM32F103核心板板一块；
* microUSB线一根（供电）；
* STLink板或USB串口板一块。

### 软件
* 交叉编译软件。

## 步骤

### 1.编写Cube程序，配置UART0为9600,8n1，上电后向串口输出“Hello”，在PC上通过串口软件观察结果；

首先打开STM32CubeMX，新建工程，按照下面的图选择要使用的板子。
![CubeMX工程配置选项](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-16%20at%205.12.22%20PM.png?imageView/2/w/619/q/90)
然后设置uart引脚。
![uart引脚设置](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-16%20at%205.19.42%20PM.png?imageView/2/w/619/q/90)
接下来Project -> Generate Code, 选择工程所在目录并且填写名字，注意选择 MKD-ARM
![uart引脚设置](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-16%20at%205.23.20%20PM.png?imageView/2/w/619/q/90)

修改代码：

	void HAL_UART_MspInit(UART_HandleTypeDef* huart)
	{
	  GPIO_InitTypeDef GPIO_InitStruct;
	  if(huart->Instance==USART1)
	  {
	  /* USER CODE BEGIN USART1_MspInit 0 */
	
	  /* USER CODE END USART1_MspInit 0 */
	    /* Peripheral clock enable */
	    __HAL_RCC_USART1_CLK_ENABLE();
	  
	    /**USART1 GPIO Configuration    
	    PA9     ------> USART1_TX
	    PA10     ------> USART1_RX 
	    */
	    GPIO_InitStruct.Pin = GPIO_PIN_9;
	    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	
	    GPIO_InitStruct.Pin = GPIO_PIN_10;
	    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	    GPIO_InitStruct.Pull = GPIO_NOPULL;
	    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	
	  /* USER CODE BEGIN USART1_MspInit 1 */
			__HAL_RCC_GPIOA_CLK_ENABLE();
			__HAL_RCC_USART1_CLK_ENABLE();
			
			GPIO_InitStruct.Pin=GPIO_PIN_9;
			GPIO_InitStruct.Mode=GPIO_MODE_AF_PP;
			GPIO_InitStruct.Speed=GPIO_SPEED_HIGH;
			HAL_GPIO_Init(GPIOA,&GPIO_InitStruct);
			GPIO_InitStruct.Pin=GPIO_PIN_10;
			HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	  /* USER CODE END USART1_MspInit 1 */
	  }
	
	}
	
	void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
	{
	
	  if(huart->Instance==USART1)
	  {
	  /* USER CODE BEGIN USART1_MspDeInit 0 */
	
	  /* USER CODE END USART1_MspDeInit 0 */
	    /* Peripheral clock disable */
	    __HAL_RCC_USART1_CLK_DISABLE();
	  
	    /**USART1 GPIO Configuration    
	    PA9     ------> USART1_TX
	    PA10     ------> USART1_RX 
	    */
	    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);
	
	  }
	  /* USER CODE BEGIN USART1_MspDeInit 1 */
			__HAL_RCC_USART1_FORCE_RESET();
			__HAL_RCC_USART1_RELEASE_RESET();
			HAL_GPIO_DeInit(GPIOA,GPIO_PIN_9);
			HAL_GPIO_DeInit(GPIOA,GPIO_PIN_10);
	  /* USER CODE END USART1_MspDeInit 1 */
	
	}


使用设置串口数据：
设置串口，注意数据位设置为7
![串口数据设置](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-17%20at%2011.38.28%20AM.png?imageView/2/w/619/q/90)

下板子：flash -> Download
若成功会输出下示信息：

	Load "STM1\\STM1.axf" 
	Erase Done.
	Programming Done.
	Verify OK.
	Flash Load finished at 11:36:27

![ST LINK连接示意图](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-17%20at%207.54.40%20PM.png?imageView/2/w/619/q/90)
![串口连接示意图](http://7xljx0.com1.z0.glb.clouddn.com/Screen%20Shot%202016-04-17%20at%207.54.49%20PM.png?imageView/2/w/619/q/90)

点击STM32重启按钮后，PC端会受到串口数据

	Hello

### 2.通过面包板在PA11和PA12各连接一个按钮开关到地；
![实际连接图](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3344.JPG?imageView/2/w/619/q/90)

### 3.编写Cube程序，配置PA11和PA12为内部上拉到输入模式，在main()函数循环检测PA11按钮按下，并在按钮按下时 在串口输出“Pressed”；
修改代码：
首先在HAL_UART_MspInit函数中添加对PA11和PA12的设置：

	GPIO_InitStruct.Pin=GPIO_PIN_11;
	GPIO_InitStruct.Mode=GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull=GPIO_PULLUP;
	GPIO_InitStruct.Speed=GPIO_SPEED_LOW;
	HAL_GPIO_Init(GPIOA,&GPIO_InitStruct);
	
	GPIO_InitStruct.Pin = GPIO_PIN_12; 
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; //下降沿触发中断
	GPIO_InitStruct.Pull = GPIO_PULLUP; 
	GPIO_InitStruct.Speed = GPIO_SPEED_LOW; 
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	/* USER CODE END USART1_MspInit 1 */

接着修改main函数，利用HAL_GPIO_ReadPin函数读取PA11的状态，如果等于0表示按下按钮。使用HAL_Delay延时500秒实现防抖动：

 	MX_USART1_UART_Init();

	/* USER CODE BEGIN 2 */

	/* USER CODE END 2 */
	printf("Start\n\r");
	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
	/* USER CODE END WHILE */
		if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11)==0)
		{
			HAL_Delay(500);
		if(HAL_GPIO_ReadPin(GPIOC,GPIOA_PIN_11)==0){
				printf("Pressed\n\r");
			}
		}
重新build工程，下载到板子，先按reset输出start，接着按下按钮就可以观察到输出Pressed

	Start
	Pressed
	Pressed
	Pressed
	Pressed
	Pressed

### 4.编写Cube程序，配置PA12下降沿触发中断，程序中设置两个全局变量，一个为计数器，一个为标识。当中断触发 时，计数器加1，并设置标识。在主循环中判断标识，如果标识置位则清除标识并通过串口输出计数值；
首先添加两个全局变量counter和flag，并初始化为0

	int counter;
	int flag;
	
	int main(void)
	{
	
	  /* USER CODE BEGIN 1 */
		counter=0;
		flag=0;
然后在HAL_UART_MspInit函数中添加对中断的设置
	
	HAL_NVIC_SetPriority(EXTI15_10_IRQn,0,0);
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

出现中断时会调用EXTI15_10_IRQHandler这个函数，所以我们要在stm32f1xx_it.c中实现这个函数。在回调函数中计数器加一，并设置标志。

	/* USER CODE BEGIN 0 */
	extern int counter;
	extern int flag;
	
	void EXTI15_10_IRQHandler(void)
	{
		HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
	}
	
	void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
	{
			counter++;
			flag = 1;
	}

最后在main函数中清除标志并输出counter值：

		if(flag)
		{
			flag=0;
			printf("counter: %d\n\r", counter);
		}

下载到板子后验证:

	Start
	counter: 1
	counter: 2
	counter: 3
	counter: 4
	counter: 5
	counter: 6
	counter: 7
	counter: 8
	counter: 9


### 5.编写Cube程序，开启定时器为200ms中断一次，中断触发时设置标识，主循环根据这个标识来做串口输出（取消4 的串口输出）；
首先编写一个函数来完成定时器的初始化：

	void MX_USART1_Timer_Init(void)
	{
		TIM_Handle.Instance = TIM3;
		TIM_Handle.Init.Prescaler = 8000;
		TIM_Handle.Init.CounterMode = TIM_COUNTERMODE_UP;
		TIM_Handle.Init.Period = 199;
		
		HAL_TIM_Base_Init(&TIM_Handle);
		
		//set clock
		TIM_ClockConfigTypeDef sClockSourceConfig;
		sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
		HAL_TIM_ConfigClockSource(&TIM_Handle,&sClockSourceConfig);
		
		//set reset mode
		TIM_MasterConfigTypeDef sMasterConfig;
		sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
		HAL_TIMEx_MasterConfigSynchronization(&TIM_Handle,&sMasterConfig);
		
		HAL_NVIC_SetPriority(TIM3_IRQn,0,0);
		HAL_NVIC_EnableIRQ(TIM3_IRQn);
	}

接着在stm32f1xx__hal_msp.c中编写HAL_TIM_Base_MspInit和HAL_TIM_Base_MspDeinit:

	void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *TIM_Handle)
	{
		__TIM3_CLK_ENABLE();
	}
	
	void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *TIM_Handle)
	{
		__TIM3_CLK_DISABLE();
	}	


编写中断处理函数和回调函数：
	extern TIM_HandleTypeDef TIM_Handle;
	extern int timer_flag;
	
	void TIM3_IRQHandler(void)
	{
		HAL_TIM_IRQHandler(&TIM_Handle);
	}
	void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
		timer_flag=1;
	}

在main中调用HAL_TIM_Base_Start_TI启动定时器：

	MX_USART1_Timer_Init();
	HAL_TIM_Base_Start_IT(&TIM_Handle);

在while循环中判断timer_flag进行输出：

	if(timer_flag){
			timer_flag=0;
			printf("Interrupt\n\r");
		}

下载到板子后就可以看到每隔200ms出现Interrupt的效果了：

	Start
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt
	Interrupt

### 6.编写完整的码表程序，PA12的按钮表示车轮转了一圈，通过计数器可以得到里程，通过定时器中断得到的时间可以 计算出速度；PA11的按钮切换模式，模式一在串口输出里程，模式二在串口输出速度。
首先在main中添加几个全局变量

	int counter;
	int flag;
	int cycles;
	int last_cycles;
	int state;
	int time;
	int timer_flag;
	
	int main(void)
	{
	
	  /* USER CODE BEGIN 1 */
		timer_flag=0;
		counter=0;
		flag=0;
		cycles=0;
		last_cycles=0;
		state=0;
		time=0;
		timer_flag=0;

然后修改PA12的回调函数：
	
	void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
	{
			//counter++;
			if(flag==0){
				cycles+=1;
				flag = 1;
			}
	}

设置一个缓冲区，记录当前时间1秒内的5个周期的cycle数

	void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
		timer_flag=1;
		int i=0;
		for(i=0;i<4;i++){
			cyclelast[i]=cyclelast[i+1];
		}
		cyclelast[i]=cycles;
		last_cycles=cyclelast[0];
	}

编写PA11和PA12按下时运行的代码：

	while (1)
	{
	/* USER CODE END WHILE */
		if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_11)==0)
		{
			HAL_Delay(500);
			if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_11)==0){
				state=!state; //改变状态
			}
		}
		if(flag)
		{
			//printf("counter: %d\n\r", counter);
			if(!state){
				printf("cycles:%d\n\r",cycles);//输出圈数
			}else{
				float speed=(cycles-last_cycles);
				printf("speed: %f(cycle/sec)\n\r",speed);
			}
			HAL_Delay(50);//去抖动
			flag=0;//标志位设为0
		}

结果：

	Start
	cycles:1
	cycles:2
	cycles:3
	cycles:4
	cycles:5
	cycles:6
	speed: 1.000000(cycle/sec)
	speed: 2.000000(cycle/sec)
	speed: 3.000000(cycle/sec)
	speed: 4.000000(cycle/sec)
	speed: 5.000000(cycle/sec)
	speed: 6.000000(cycle/sec)
	speed: 7.000000(cycle/sec)
	speed: 8.000000(cycle/sec)
	speed: 9.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 9.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 11.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 11.000000(cycle/sec)
	speed: 9.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 9.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 10.000000(cycle/sec)
	speed: 8.000000(cycle/sec)
	speed: 7.000000(cycle/sec)
	speed: 8.000000(cycle/sec)
	speed: 7.000000(cycle/sec)
	speed: 2.000000(cycle/sec)
	speed: 3.000000(cycle/sec)
	speed: 3.000000(cycle/sec)
	speed: 4.000000(cycle/sec)
	speed: 5.000000(cycle/sec)
	speed: 6.000000(cycle/sec)
	speed: 7.000000(cycle/sec)
	speed: 8.000000(cycle/sec)