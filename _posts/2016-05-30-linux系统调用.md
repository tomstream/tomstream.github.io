---
layout: post
title: 树莓派上的Linux系统调用

---
这篇文章的目的是学会配置和编译移植到ARM上的Linux内核，深入理解Linux系统调用，比较 ARM和x86系统调用的不同。### 目的学习Linux内核的配置和编译；
深入理解Linux系统调用； 
理解ARM和x86的CPU模式（系统模式、用户模式等）的不同。 掌握内核模块的编写方法。 ### 步骤使用交叉编译工具或本机编译工具，通过Linux内核源码进行实验:#### 寻找、下载Linux实验板卡所用的Linux内核源码;
我选用的内核版本是`linux-rpi-4.4`，首先设置`ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-`,然后执行`make  bcm2709_defconfig`对配置文件进行默认设置。

编译前还有一些依赖项，按照官方文档可使用命令`sudo apt-get install bc`来获得

之后就可以进行`make -j4 zImage modules dtbs`操作，过程中可能会出现一些模块的缺失，只需要相应的添加模块即可。

编译完成后，开始安装，将树莓派的SD卡插入电脑：
按照官方指南的要求进行挂载：

	# 建立挂载点
	mkdir /mnt/fat32
	mkdir /mnt/ext4
	
	# 挂载
	# fat32挂载boot
	sudo mount -t vfat /dev/sdb1 /mnt/fat32
	# ext4挂载根文件夹
	sudo mount -t ext4 /dev/sdb2 /mnt/ext4
	
注意这里的sdb1和sdb2需要根据实际的情况进行调整。其中sdb1对应FAT(boot)，sdb2对应root(ext4)

在实际的情况中，我的挂在命令如下：

	➜  linux-rpi-4.4.y sudo mount -t vfat /dev/sdc6 /mnt/fat32
	➜  linux-rpi-4.4.y sudo mount -t ext4 /dev/sdc7 /mnt/ext4 

然后在文件系统中安装编译出来的模块：

	➜  linux-rpi-4.4.y sudo make INSTALL_MOD_PATH=/mnt/ext4 modules_install

接着继续按照官方教程做：

	sudo cp mnt/fat32/$KERNEL.img mnt/fat32/$KERNEL-backup.img
	sudo scripts/mkknlimg arch/arm/boot/zImage mnt/fat32/$KERNEL.img
	sudo cp arch/arm/boot/dts/*.dtb mnt/fat32/
	sudo cp arch/arm/boot/dts/overlays/*.dtb* /mnt/fat32/overlays/
	sudo cp arch/arm/boot/dts/overlays/README /mnt/fat32/overlays/
	sudo umount /mnt/fat32
	sudo umount /mnt/ext4
	
这个时候直接将SDcard插到树莓派上，上电就可以启动了。

启动后查看系统版本信息：

	pi@raspberrypi:~ $ uname -a
	Linux raspberrypi 4.4.11 #1 Mon May 28 13:56:43 CST 2016 armv6l GNU/Linux

可以看到更新时间为**5月28号**，也就是说刚才编译好的内核安装成功了！

### 添加系统调用在内核中加入新的系统调用，具体功能没有要求，能输出调试信息即可; 在arch/arm/kernel中新建一个sys_mysyscall.c文件，内容为系统调用的具体功能：

	#include <linux/kernel.h>
	void sys_mysyscall(void){
		printk(KERN_ALERT"mysys start\n");
		printk(KERN_ALERT"Hello!\n");
		printk(KERN_ALERT"mysys end\n");
	}
	修改Makefile目录下的obj-y字段，将sys_mysyscall.o加入目标文件中。
	# Object file lists.		obj-y		:= elf.o entry-common.o irq.o opcodes.o \			   process.o ptrace.o reboot.o return_address.o \			   setup.o signal.o sigreturn_codes.o \			   stacktrace.o sys_arm.o time.o traps.o sys_mysyscall.o而后，需要让操作系统知道这个函数是处理某个系统调用的函数。此时，需要修改系统的中断向量表。此时需要修改arch/arm/kernel/calls.S文件。选择没有使用的223号进行调换。
		/* 220 */	CALL(sys_madvise)			CALL(ABI(sys_fcntl64, sys_oabi_fcntl64))			CALL(sys_ni_syscall) /* TUX */			CALL(sys_mysyscall)			CALL(sys_gettid)
在include/uapi/asm-generic/unistd.h头文件中将223号调用与某个宏进行关联，在syscall()中注册一个位置，方便调用。

	//#define __NR3264_fadvise64 223	//__SC_COMP(__NR3264_fadvise64, sys_fadvise64_64, compat_sys_fadvise64_64)	#define __NR_mysyscall 223	__SYSCALL(__NR_mysyscall, sys_mysyscall)重新编译内核后，启动树莓派，如下分别使用了**汇编**和**syscall**的方式使用自己添加的系统调用：
	#include <stdio.h>
	#define sys_call() {__asm__ __volatile__ ("swi 0x900000+223\n\t");} while(0)
	
	int main(void) {
	    sys_call();
	    return 0;
	}

# 

	#include <linux/unistd.h>
	#include <sys/syscall.h>
	
	int main(){
	    syscall(223);
	    return 0;
	}
然后分别编译运行编写用户程序读取`/var/log/kern.log`文件中的系统输出信息：

	#include <stdio.h>
	#include <string.h>
	
	//过滤掉log方括号中的信息
	char* go_through(char *s)
	{
		for(;*s!=0;s++)
		{
			if(*s==']')
				break;
		}
		return s+2;
	}
	
	int main()
	{
		char buffer[500];
		char *head;
		FILE* fp=fopen("/var/log/kern.log","r");
		long offset;
		// traverse all the line,mark the tag
		while(!feof(fp))
		{
			fgets(buffer,500,fp);
			head = go_through(buffer);
			if(!strncmp(head,"mysys start",strlen("mysys start")))
			{
				offset=ftell(fp);
			}
		}
		puts("mysys Start");
		fseek(fp,offset,SEEK_SET);
		// traverse the print the aimed infomation
		while(!feof(fp))
		{
			fgets(buffer,500,fp);
			head = go_through(buffer);
			if(!strncmp(head,"mysys end",strlen("mysys end")))
			{
				printf("%s",head);
				break;
			}
			printf("%s",head);
		}
		return 0;
	}输出结果：
	pi@raspberrypi:~ $ gcc user.c
	pi@raspberrypi:~ $ ./a.out
	mysys start
	Hello!
	mysys end
		### 修改内核代码配置，编译内核； 
这里我直接使用了操作系统实验课的内核模块代码，简单地输出一行信息：
	#include <linux/module.h>	#include <linux/sched.h>	#include <linux/list.h>		// init the module	int init_module(void){		printk(KERN_ALERT"Hello Start\n");		printk(KERN_ALERT"Hello World!\n");		printk(KERN_ALERT"Hello End\n");				return 0;	}		void cleanup_module(void){		printk(KERN_ALERT"Goodbyte!\n");	}	MODULE_LICENSE("GPL");
	
然后编写交叉编译用的makefile 文件：

	obj-m := hello
	KERNEL_VER := 4.4.11-v7
	KERNEL_DIR := /mnt/ext4/lib/modules/$(KERNEL_VER)/build
	
	PWD := $(shell pwd)
	ARGS := ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
	all:
	    make -C $(KERNEL_DIR) SUBDIRS=$(PWD) $(ARGS) modules

执行make后，加载模块：

	pi@raspberrypi:~ $ sudo insmod hello.ko
	pi@raspberrypi:~ $ sudo lsmod
	Module                  Size  Used by	hello                  12426  0 
	
修改之前编写的用户态程序读取`/var/log/kern.log`文件中的内核模块输出信息：

	#include <stdio.h>
	#include <string.h>
	
	//过滤掉log方括号中的信息
	char* go_through(char *s)
	{
		for(;*s!=0;s++)
		{
			if(*s==']')
				break;
		}
		return s+2;
	}
	
	int main()
	{
		char buffer[500];
		char *head;
		FILE* fp=fopen("/var/log/kern.log","r");
		long offset;
		// traverse all the line,mark the tag
		while(!feof(fp))
		{
			fgets(buffer,500,fp);
			head = go_through(buffer);
			if(!strncmp(head,"Hello Start",strlen("Hello Start")))
			{
				offset=ftell(fp);
			}
		}
		puts("Hello Start");
		fseek(fp,offset,SEEK_SET);
		// traverse the print the aimed infomation
		while(!feof(fp))
		{
			fgets(buffer,500,fp);
			head = go_through(buffer);
			if(!strncmp(head,"Hello End",strlen("Hello End")))
			{
				printf("%s",head);
				break;
			}
			printf("%s",head);
		}
		return 0;
	}输出结果：
	pi@raspberrypi:~ $ gcc user.c
	pi@raspberrypi:~ $ ./a.out
	Hello Start
	Hello World!
	Hello End