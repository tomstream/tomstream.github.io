---
layout: post
title: 字符设备驱动程序
---



---

这篇文章的目的是掌握在嵌入式Linux中如何使用已有的函数库编写应用程序操纵树莓派的GPIO，如何编写字符设备驱动程序在内核程序中使用GPIO，并学习用面包板搭简单的外部设备电路的方法。

我使用装有linux的树莓派，连接了两个级联的74HC595，由595的输出端控制一个8x8的LED矩阵。通过两个GPIO引脚 分别控制595的时钟和数据输入端，可以实现对LED矩阵的控制，在矩阵上显示文字和图案。

### 目的

1. 学习嵌入式Linux的GPIO的使用方式；
2. 学习嵌入式Linux的Arduino接口库；
3. 学习使用面包板搭简单的外部电路；
4. 学习Linux设备驱动程序的开发过程。
5. 学习在内核中访问外设寄存器，操纵外设的方法。

## 步骤

### 连线
首先按照图示方式进行连线：

![rpi－max7219连线图](http://7xljx0.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87dd%201.png?imageView/2/w/300/q/90)

### 使用虚拟文件系统对gpio进行访问

树莓派目录`/sys/class/gpio`目录下的文件可以通过读写的方式访问gpio。

`/sys/class/gpio`目录下文件一览：

	pi@raspberrypi:/sys/class/gpio $ ls
	export  gpiochip0  unexport

其中`export`和`unexport`都是只写的文件，可以通过写入`export`和`unexport`进行添加或删除gpio访问的操作。

启用gpio18:

	pi@raspberrypi:/sys/class/gpio $ sudo echo 18 > export

然后接可以看到一个新的文件夹`gpio18`：

	pi@raspberrypi:/sys/class/gpio $ ls
	export  gpio18  gpiochip0  unexport
	pi@raspberrypi:/sys/class/gpio $ cd gpio18
	pi@raspberrypi:/sys/class/gpio/gpio18 $ ls
	active_low  device  direction  edge  power  subsystem  uevent  value
	
可以通过写入`direction`文件`in`或者`out`指定输入或输出，此外，在输出的基础上，在`value`中输入1或0可将输出对应电平。

	pi@raspberrypi:/sys/class/gpio/gpio8 $ sudo echo out > direction
	pi@raspberrypi:/sys/class/gpio/gpio8 $ sudo echo 1 > value

按照这个思路，可以编写c语言程序来实现对虚拟文件的操作。这里参考了[别人的代码](https://github.com/JackWang822/RaspGPIODriver/blob/master/gpio_sysfs/gpio_sys.c)。

我封装了export,read,write,direction等几个函数来方便使用gpio操作：

	#include "gpio_sys.h"
	#include <sys/stat.h>
	#include <sys/types.h>
	#include <fcntl.h>
	#include <unistd.h>
	#include <string.h>
	
	int GPIOExport(int pin)
	{
	    char buff[BUFFMAX];
	
	    int fd;
	    if((fd=open(SYSFS_GPIO_EXPORT, O_WRONLY)) == -1)
	    {
	        ERR("Failed to open export for writing!\n");
	        return -1;
	    }
	
	    int len = snprintf(buff, sizeof(buff), "%d", pin);
	    if(write(fd, buff, len) == -1)
	    {
	        ERR("Failed to export gpio!\n");
	        return -1;
	    }
	
	    if(close(fd) == -1)
	    {
	        ERR("Failed to close export!\n");
	        return -1;
	    }
	    return 0;
	}
	
	int GPIOUnexport(int pin)
	{
	    char buff[BUFFMAX];
	    int fd;
	    if((fd=open(SYSFS_GPIO_UNEXPORT, O_WRONLY)) == -1)
	    {
	        ERR("Failed to open unexport for writing!\n");
	        return -1;        
	    }
	
	    int len = snprintf(buff, sizeof(buff), "%d", pin);
	    if(write(fd, buff, len) == -1)
	    {
	        ERR("Failed to unexport gpio!\n");
	        return -1;
	    }
	
	    if(close(fd) == -1)
	    {
	        ERR("Failed to close unexport!\n");
	        return -1;
	    }
	    return 0;
	}
	
	int GPIODirection(int pin, int dir)
	{
	    char dirCh[][5] =  {"in", "out"};
	    char path[64];
	
	    int fd;
	    snprintf(path, sizeof(path), "/sys/class/gpio/gpio%d/direction", pin);
	    printf(path);
	    if((fd = open(path, O_WRONLY)) == -1)
	    {
	        ERR("Failed to open direction for writing!\n");
	        return -1;    
	    }
	
	    if(write(fd, dirCh[dir], strlen(dirCh[dir])) == -1)
	    {
	        ERR("Failed to set direction!\n");
	        return -1;        
	    }
	
	    if(close(fd) == -1)
	    {
	        ERR("Failed to close direction!\n");
	        return -1;
	    }
	    return 0;
	}
	
	int GPIORead(int pin)
	{
	    char path[64];
	    char buff[BUFFMAX];
	
	    snprintf(path, sizeof(path), "/sys/class/gpio/gpio%d/value", pin);
	
	    int fd;
	    if((fd == open(path, O_RDONLY)) == -1)
	    {
	        ERR("Failed to open value for reading!\n");
	        return -1;    
	    }
	
	    if(read(fd, buff, sizeof(buff)) == -1)
	    {
	        ERR("Failed to read value!\n");
	        return -1;
	    }
	
	    if(close(fd) == -1)
	    {
	        ERR("Failed to close value!\n");
	        return -1;
	    }
	
	    return atoi(buff);
	}
	
	int GPIOWrite(int pin, int value)
	{
	    char path[64];
	    char valuestr[][2] = {"0", "1"};
	    
	    if(value != 0 && value != 1)
	    {
	        fprintf(stderr, "value = %d\n", value);
	        ERR("Writing erro value!\n");
	        return -1;
	    }
	    snprintf(path, sizeof(path), "/sys/class/gpio/gpio%d/value", pin);
	    int fd;
	    if((fd = open(path, O_WRONLY)) == -1)
	    {
	        ERR("Failed to open value for writing!\n");
	        return -1;    
	    }
	
	    if(write(fd, valuestr[value], 1) == -1)
	    {
	        ERR("Failed to write value!\n");
	        return -1;
	    }
	
	    if(close(fd) == -1)
	    {
	        ERR("Failed to close value!\n");
	        return -1;
	    }
	    return 0;
	}

然后编写MAX_7219相关的代码。

MAX_7219其输出引DIG0-7和SEG A-G连接了8*8的LED矩阵，而编程关心的是其输入的5个引脚，分别是5V的VCC和接地GND，以及时钟信号CLK，片选信号CS，串行数据输入端口DIN。

MAX_7219使用前需要对一些寄存器进行初始化设置，包括编码寄存器，亮度寄存器，模式寄存器以及显示检测寄存器。

![](http://images2015.cnblogs.com/blog/784203/201606/784203-20160604040221414-1843325618.png)

MAX_7219的数据的写入是在时钟上升沿写入的，连续数据的后16位被移入寄存器中，其中8-11为地址，0-7位为数据。

首先编写MAX_7219数据写入程序：

	void Write_Max7219(uchar address,uchar dat)
	{ 
	     GPIOWrite(pinCS, SYSFS_GPIO_VAL_LOW); 
	     Write_Max7219_byte(address);           //writing address
	     Write_Max7219_byte(dat);               //writing data 
	     GPIOWrite(pinCS, SYSFS_GPIO_VAL_HIGH);                      
	}

然后初始化MAX_7219的一些设置：

	Write_Max7219(0x09, 0x00);       //encoding with BCD
    Write_Max7219(0x0a, 0x03);       //luminance
    Write_Max7219(0x0b, 0x07);       //scanning bound
    Write_Max7219(0x0c, 0x01);       //mode: normal
    Write_Max7219(0x0f, 0x00);       

同样可以实现完整字节的写入：

	void Write_Max7219_byte(uchar DATA)         
	{
	    uchar i;   
	    GPIOWrite(pinCS, SYSFS_GPIO_VAL_LOW); 
	    for(i=8;i>=1;i--)
	    {
	        GPIOWrite(pinCLK, SYSFS_GPIO_VAL_LOW);
	        GPIOWrite(pinDIN, (DATA&0x80) >> 7);
	        DATA <<= 1;
	        GPIOWrite(pinCLK, SYSFS_GPIO_VAL_HIGH);
	    }                                 
	}

接下来规定0-9A-Za-z的字符点阵数组：

	uchar codeDisp[38][8]={
	    {0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//0
	    {0x10,0x18,0x14,0x10,0x10,0x10,0x10,0x10},//1
	    {0x7E,0x2,0x2,0x7E,0x40,0x40,0x40,0x7E},//2
	    {0x3E,0x2,0x2,0x3E,0x2,0x2,0x3E,0x0},//3
	    {0x8,0x18,0x28,0x48,0xFE,0x8,0x8,0x8},//4
	    {0x3C,0x20,0x20,0x3C,0x4,0x4,0x3C,0x0},//5
	    {0x3C,0x20,0x20,0x3C,0x24,0x24,0x3C,0x0},//6
	    {0x3E,0x22,0x4,0x8,0x8,0x8,0x8,0x8},//7
	    {0x0,0x3E,0x22,0x22,0x3E,0x22,0x22,0x3E},//8
	    {0x3E,0x22,0x22,0x3E,0x2,0x2,0x2,0x3E},//9
	    {0x8,0x14,0x22,0x3E,0x22,0x22,0x22,0x22},//A
	    {0x3C,0x22,0x22,0x3E,0x22,0x22,0x3C,0x0},//B
	    {0x3C,0x40,0x40,0x40,0x40,0x40,0x3C,0x0},//C
	    {0x7C,0x42,0x42,0x42,0x42,0x42,0x7C,0x0},//D
	    {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x7C},//E
	    {0x7C,0x40,0x40,0x7C,0x40,0x40,0x40,0x40},//F
	    {0x3C,0x40,0x40,0x40,0x40,0x44,0x44,0x3C},//G
	    {0x44,0x44,0x44,0x7C,0x44,0x44,0x44,0x44},//H
	    {0x7C,0x10,0x10,0x10,0x10,0x10,0x10,0x7C},//I
	    {0x3C,0x8,0x8,0x8,0x8,0x8,0x48,0x30},//J
	    {0x0,0x24,0x28,0x30,0x20,0x30,0x28,0x24},//K
	    {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7C},//L
	    {0x81,0xC3,0xA5,0x99,0x81,0x81,0x81,0x81},//M
	    {0x0,0x42,0x62,0x52,0x4A,0x46,0x42,0x0},//N
	    {0x3C,0x42,0x42,0x42,0x42,0x42,0x42,0x3C},//O
	    {0x3C,0x22,0x22,0x22,0x3C,0x20,0x20,0x20},//P
	    {0x1C,0x22,0x22,0x22,0x22,0x26,0x22,0x1D},//Q
	    {0x3C,0x22,0x22,0x22,0x3C,0x24,0x22,0x21},//R
	    {0x0,0x1E,0x20,0x20,0x3E,0x2,0x2,0x3C},//S
	    {0x0,0x3E,0x8,0x8,0x8,0x8,0x8,0x8},//T
	    {0x42,0x42,0x42,0x42,0x42,0x42,0x22,0x1C},//U
	    {0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18},//V
	    {0x0,0x49,0x49,0x49,0x49,0x2A,0x1C,0x0},//W
	    {0x0,0x41,0x22,0x14,0x8,0x14,0x22,0x41},//X
	    {0x41,0x22,0x14,0x8,0x8,0x8,0x8,0x8},//Y
	    {0x0,0x7F,0x2,0x4,0x8,0x10,0x20,0x7F},//Z
	};
	
	
最后编写main函数调用这些已定义的数据和函数，实现gpio输出驱动MAX_7219显示：
	
	int main(void)
	{
	    uchar i,j;
	     Delay_xms(50);
	     GPIORelease();
	     if(GPIOConfig() != 0)
	     {
	         ERR("Can not configure the gpio!\n")
	         return 0;
	     }
	     Init_MAX7219();
	     while(1)
	     {
	          for(j=0;j<38;j++)
	          {
	               for(i=1;i<9;i++)
	                	Write_Max7219(i,codeDisp[j][i-1]);
	               Delay_xms(1000);
	          }  
	     }
	
	     if(GPIORelease() != 0)
	     {
	         ERR("Release the gpio error!\n")
	         return 0;
	     }
	}

![](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3764.JPG?imageView/2/w/300/q/90)
![](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3759.JPG?imageView/2/w/300/q/90)
![](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3761.JPG?imageView/2/w/300/q/90)
![](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3757.JPG?imageView/2/w/300/q/90)

## 编写字符设备驱动程序
对于通过寄存器操作GPIO，只需知道树莓派上各个GPIO端口的寄存器的地址，在树莓派的CPU（bcm2825）的芯片手册上[https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf](https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf)可以查到

这个程序的编写我参考了网上的bcm2835的对于GPIO操作的一个bcm2835的一个开源的函数库。
	
	//0->input  1-<output
	static void bcm2835_gpio_fsel(int pin, int functionCode)
	{
	    int registerIndex = pin / 10;
	    int bit = (pin % 10) * 3;
	
	    unsigned oldValue = s_pGpioRegisters-> GPFSEL[registerIndex];
	    unsigned mask = 0b111 << bit;
	    printk("Changing function of GPIO%d from %x to %x\n", 
	           pin,
	           (oldValue >> bit) & 0b111,
	           functionCode);
	
	    s_pGpioRegisters-> GPFSEL[registerIndex] = 
	        (oldValue & ~mask) | ((functionCode << bit) & mask);
	}
	
	static void bcm2835_gpio_set(int pin)
	{
	    printk("GPIO set %d\n oldValue=%d", pin, s_pGpioRegisters->GPSET[0]);
	    s_pGpioRegisters-> GPSET[pin / 32] = (1 << (pin % 32));      
	    printk("GPIO set %d\n oldValue=%d", pin, s_pGpioRegisters->GPSET[0]);
	}
	
	static void bcm2835_gpio_clr(int pin)
	{
	    printk("GPIO clear %d\n oldValue=%d", pin, s_pGpioRegisters->GPCLR[0]);
	    s_pGpioRegisters-> GPCLR[pin / 32] = (1 << (pin % 32));
	    printk("GPIO clear %d\n newValue=%d", pin, s_pGpioRegisters->GPCLR[0]);
	}

在完成对于GPIO的操作函数之后就可以开始编写字符驱动程序了，Linux的字符驱动程序主要以模块的形式装载到内核中，然后应用程序通过文件的操作的方式对于硬件进行操作。

首先需要做的是对于驱动进行初始化设置，在模块的初始化函数中编写如下，首先获得一个设备号（静态或者动态获取），然后进行字符设备的初始化，主要是将file_operation这个结构体中的函数和定义的函数进行绑定，注册字符设备，最后创建得到设备。然后在进行设备的初始化，这里首先获取的是GPIO寄存器的基地址，然后通过fsel函数设置相关的三个GPIO口的模式为OUT，然后通过这三个GPIO去初始化MAX7219。这里我参考了一个[开源的代码](https://github.com/JackWang822/RaspGPIODriver)

	static struct file_operations MAX7219_cdev_fops = {
	    .owner = THIS_MODULE,
	    .open = MAX7219_open,
	    .write = MAX7219_write,
	    .release = MAX7219_release,
	};
	
	static int MAX7219_init(void)
	{
	    int ret;
	
	    MAX7219_dev_id = MKDEV(major, 0);
	    if(major)    //static allocate 
	        ret = register_chrdev_region(MAX7219_dev_id, 1, DRIVER_NAME);
	    else    //dynamic allocate
	    {
	        ret = alloc_chrdev_region(&MAX7219_dev_id, 0, 1, DRIVER_NAME);
	        major = MAJOR(MAX7219_dev_id);
	    }
	
	    if(ret < 0)
	        return ret;
	
	    cdev_init(&MAX7219_cdev, &MAX7219_cdev_fops);    //initialize character dev
	    cdev_add(&MAX7219_cdev, MAX7219_dev_id, 1);                //register character device
	    MAX7219_class = class_create(THIS_MODULE, DRIVER_NAME);    //create a class
	    device_create(MAX7219_class, NULL, MAX7219_dev_id, NULL, DRIVER_NAME);    //create a dev
	
	    s_pGpioRegisters = (struct GpioRegisters *)__io_address(GPIO_BASE);
	
	    printk("address = %x\n", (int)__io_address(GPIO_BASE));
	    
	    //gpio configure
	    bcm2835_gpio_fsel(pinCLK, 1);
	    bcm2835_gpio_fsel(pinCS, 1);
	    bcm2835_gpio_fsel(pinDIN, 1);
	
	    //initialize the MAX7219
	    Init_MAX7219();
	
	    printk("MAX7219 init successfully");
	    return 0;
	}
	
当这个内核模块退出的时候，需要通过device_destroy函数将这个设备删除，以便设备号可以提供给其他的设备宋，并且将其从注册中删除。

	void MAX7219_exit(void)
	{
	    device_destroy(MAX7219_class, MAX7219_dev_id);
	    class_destroy(MAX7219_class);
	    unregister_chrdev_region(MAX7219_dev_id, 1);
	    printk("MAX7219 exit successfully\n");
	}
	
然后就需要编写file_operations中的函数，这里主要定义了用的open，write和release（close）函数，对于read，iocnl等等就没有进行定义。

	static int MAX7219_open(struct inode *inode, struct file *flip)
	{
	    printk("Open the MAX7219 device!\n");
	    if(state != 0)
	    {
	        printk("The file is opened!\n");    
	        return -1;
	    }
	    state++;
	    printk("Open MAX7219 successfully!\n");
	    return 0;
	}
	
Release函数将打开的文件关闭即可。

	static int MAX7219_release(struct inode *inode, struct file *flip)
	{
	    printk("Close the MAX7219 device!\n");
	    if(state == 1)
	    {
	        state = 0;
	        printk("Close the file successfully!\n");
	        return 0;
	    }
	    else
	    {
	        printk("The file has closed!\n");
	        return -1;
	    }
	}

接下来是write函数，将用户送来的一个字符需要显示在MAX7219上，其显示的方法和前面的虚拟文件操作基本相同，只是GPIO口操作调用的函数不同。其首先需要将用户空间传递过来的参数通过copy_from_user函数拷贝到内核空间上，然后将调用相关的显示函数进行显示即可。

	static ssize_t MAX7219_write(struct file *filp, const char __user *buf, size_t len, loff_t *off)
	{
	    printk("Write %s into the MAX7219\n", buf);
	    int ret, i;
	    char ch;
	    if(len == 0)
	        return 0;
	    
	    if(copy_from_user(&ch, (void *)buf, 1))
	        ret = -EFAULT;
	    else
	    {
	        int index;
	        if(ch >= '0' && ch <= '9')
	            index = ch - '0';
	        else if(ch >= 'A' && ch <= 'Z')
	            index = ch - 'A' + 10;
	        else if(ch >= 'a' && ch <= 'z')
	            index = ch - 'a' + 10;
	        else
	            index = 36;    //unknown display 中
	        printk("Write character %c, index=%d\n", ch, index);
	        for(i=0;i<8;i++)
	            Write_Max7219(i+1, codeDisp[index][i]);
	
	        ret = 1;    //write a character
	    }
	
	    return ret;
	}

最后，编写Makefile文件进行编译

	ARCH        := arm
	CROSS_COMPILE    := arm-linux-gnueabi-
	
	CC := $(CROSS_COMPILE)gcc
	LD := $(CROSS_COMPILE)ld
	
	obj-m := gpio_chdev.o
	
	KERNELDIR := /home/jack/Documents/course/EmbededSystem/RaspberrySource/modules/lib/modules/4.4.11/build
	PWD = $(shell pwd)
	
	all:
	    make -C $(KERNELDIR) M=$(PWD) modules
	clean:
	    rm -f *.o *.mod.c *.symvers *.order
	    
