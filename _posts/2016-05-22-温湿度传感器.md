---
layout: post
title: uC/OS室温计

---
 
---

这个实验的目的是理解uC/OS II的任务调度方式，编写uC/OS II的应用程序，通过寄存器直接操纵GPIO来驱动外 部设备。


## 目的

1.学习uC/OS II的应用程序编写；
2.理解如何直接操纵GPIO，体会与Linux的不同；
3.学习单总线设备的访问方式；
4.学习7段数码管的时分复用驱动方式。

## 器材

### 硬件

STM32F103板一块；
USB串口板一块；
面包板一块；
两位7段数码管（共阳）一颗；
360Ω 1/8W电阻2颗；
DHT-11 温湿度传感器1个；
面包线若干。

### 软件

编译软件；
Fritzing。

## 步骤
### 移植ucOS代码
首先在[Download “Micrium_STM32xxx_uCOS-II”](https://www.micrium.com/download/micrium_stm32xxx_ucos-ii/)下载usOS源代码。

新建Keil工程，选择合适的板子型号后进入运行环境页面。选择需要的环境进入工程。

![](http://7xljx0.com1.z0.glb.clouddn.com/s.png)

接下来将ucOS一直到STM32（Cortex-M3）平台，具体可以参考官方的AN-1018文档。下图显示了ucOS一直到Cortex-M3上相关代码和模块间的关系：

![](http://images2015.cnblogs.com/blog/784203/201605/784203-20160521100802341-702115272.png)

其中最上层是应用层，即我们自己写的程序，然后最下层是ucos的源代码，主要对应ucos-II中的src和port文件夹里的代码。在工程目录和实际目录中新建Output，User和ucOS-II文件夹，分别对应上面的几个模块，其中Output作为工程的输出，在其中建立Obj和List两个文件夹，User下为用户程序。此外还需要在ucOS-II下建立两个目录Src和Ports目录，分别和源码对应。

然后在Project的Option的Output下，Select Folder for Objects，选择Output下的Obj文件夹，并且同时勾选Create HEX File，Listing目录下Select Folder for Listings选择Output目录下的List文件夹。

接下来就是拷贝代码的工作。将Micrium\Software\uCOS-II\Ports\ARM-Cortex-M3\Generic\RealView这个文件夹中的内容拷贝到uCOS-II\uCOS-Port目录, uCOS-II\Source这个文件夹中的内容拷贝到uCOS-II \uCOS-Src目录，将Micrium\Software\EvalBoards\ST\STM3210B-EVAL\RVMDK\OS-Probe目录下的app_cfg.h，os_cfg.h和includes.h文件拷贝到User目录下，加入对应Group中，并且在User中添加入一个应用程序文件app.c。然后在工程右击Manage Project Items，添加几个和工程目录中相应的Group，并分别将这些代码文件其加入工程中的对应的Group中。

最终的代码结构如下：

![](http://images2015.cnblogs.com/blog/784203/201605/784203-20160521100815654-2134326652.png)

为了所有的能够直接include，将所有涉及的依赖目录都添加到Options的C/C++标签下面的Include Paths中，并在Define中加上USE_STDPERIPH_DRIVER.

接下来则是代码修改的部分，修改os_cfg.h文件，#define OS_APP_HOOKS_EN 1为0，禁用钩子函数。

编译之后会提示os_cpu_c.c文件中OS_CPU_SysTickClkFreq函数没有定义，这里可以之间将其改正72MHZ（Cortex-M3），当然如果为了更好的适配性，可以将其改成system_stm32f10x.c文件下的一个变量SystemCoreClock。

重新编译，发现“includes.h”中很多文件不存在，直接将其注释掉即可。

	//#include  <cpu.h>	//#include  <lib_def.h>	//#include  <lib_mem.h>	//#include  <lib_str.h>		#include  <stm32f10x_conf.h>	//#include  <stm32f10x_lib.h>		#include  <app_cfg.h>	//#include  <lcd.h>	//#include  <bsp.h>		#if (APP_OS_PROBE_EN == DEF_ENABLED)	//#include  <os_probe.h>	#endif		#if (APP_PROBE_COM_EN == DEF_ENABLED)	//#include  <probe_com.h>		#if (PROBE_COM_METHOD_RS232 == DEF_ENABLED)	//#include  <probe_rs232.h>

上面只是一些简单的文件的复制，而要将ucos移植到stm32还需要使它们的底层建立联系。uCOS-II的核心就是任务调度，其必须使用STM32的一个PendSV这个中断。还有就是uCOS-II需要一个基准时间，其使用STM32中的一个专为操作系统设置的定时器SysTick。比较简单的解决方案是，在启动文件startup_stm32f10x_md.s中将所有的PendSV_Handler全部替换成为OS_CPU_PendSVHandler, SysTick_Handler 替换成OS_CPU_SysTickHandler，每个各有三处。也可以采用网上说的在外面实现这两个函数。

这样就完成了uCOS到STM32的整个移植过程。

### 访问GPIO
我使用点亮LED灯的方式来验证GPIO的正常访问。
在app.c中写入一些的代码，其新建了两个任务，分别对应用来点亮两个LED灯。系统首先进行初始化，然后创建两个任务。

	#include "includes.h"	#include "ucos_ii.h"	#define LED0STKSIZE 1000	#define LED1STKSIZE 1000		void LED_GPIO_Init(void)	{	    GPIO_InitTypeDef GPIO_InitStruct;	    RCC_DeInit();	    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;    	    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;	    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;	    GPIO_Init(GPIOA, &GPIO_InitStruct);	}    		void Task_LED0(void *p_arg)	{	    while(1)	    {	        GPIO_SetBits(GPIOA, GPIO_Pin_9);    //on	        OSTimeDly(50);                    //half second	        GPIO_ResetBits(GPIOA, GPIO_Pin_9);    //off	        OSTimeDly(50);	    }	}		void Task_LED1(void *p_arg)	{	    while(1)	    {	        GPIO_SetBits(GPIOA, GPIO_Pin_10);    //on	        OSTimeDly(100);    //one second	        GPIO_ResetBits(GPIOA, GPIO_Pin_10);    //off	        OSTimeDly(100);	    }	}		OS_STK LED0TaskStk[LED0STKSIZE];	OS_STK LED1TaskStk[LED1STKSIZE];	int main()	{	    LED_GPIO_Init();    //initialize the gpio	    OSInit();                    //initialize the os	    OS_CPU_SysTickInit();    //initialze the system clock	    //create two task LED0 and LED1	    OSTaskCreate(Task_LED0, (void *)0, &LED0TaskStk[LED0STKSIZE - 1], 5);	    OSTaskCreate(Task_LED1, (void *)0, &LED1TaskStk[LED1STKSIZE - 1], 6);	    OSStart();    //start the os	    return 0;	}

连好并下板后，就可以看到闪烁的两盏灯：

![](http://7xljx0.com1.z0.glb.clouddn.com/IMG_3617.JPG?imageView/2/w/619/q/90)

### 七段数码管显示

![](http://images2015.cnblogs.com/blog/784203/201605/784203-20160521102652544-1052421714.png)

七段数码管LG3641BH的引脚图如上面两幅图所示，其中A-G分别对应一个数字的七段(A-G对应如右图所示)，DP表示小数点，D1-D4表示位选信号。

每次我们只需要通过位选信号来显示一个数字即可以，然后利用时分复用的原理依次快速点亮其他的数字，使得眼睛看起来是同时亮起来的。

实验中采用了GPIO的PA0-7引脚作为七段数码端的7段以及DP，PA9-12作为四个位选信号D1-D4。

下面为七段数码管的显示代码，digitSel为位选设置，通过传入的一个位选信号，设置PA9-12这几个位选信号的值。digitDisp为显示信号，根据传入的一个 数字以及小数点然后设置PA0-7这几个GPIO的值。

TaskDisp为显示七段数码管的任务，其中不断的扫描每一位数字，使得人眼看上去是一起显示的。这里需要注意的是由于位选控制和数字显示有前后之分，因此会出现某一个变化了另一个还没有变化的情况，因此这里将时间比较长的数字显示放在前面以此缩短两个GIPO的不统一的时间。而且后面加上了一个循环7000的延时，如果采用uCOS自带的定时函数，由于其精度太低，会出现闪烁，而如果这个计数设置的过小，则会出现重影。

TaskInc为value的递增任务，没个1秒其增加1，而且其任务的优先级需要比TaskDisp高，否则其不会得到执行。

	#include "includes.h"
	#include "ucos_ii.h"
	
	#define LED0STKSIZE 1000
	#define LED1STKSIZE 1000
	
	void GPIO_Config(void)
	{
	    GPIO_InitTypeDef GPIO_InitStruct;
	    RCC_DeInit();
	    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	    
	    //digit select
	    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12;
	    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
	    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_2MHz;
	    GPIO_Init(GPIOA, &GPIO_InitStruct);
	
	    //7-segment and one point
	    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0 |
	                                                         GPIO_Pin_1 |
	                                                       GPIO_Pin_2 |
	                                                         GPIO_Pin_3 |
	                                                         GPIO_Pin_4 |
	                                                       GPIO_Pin_5 |
	                                                       GPIO_Pin_6 |
	                                                       GPIO_Pin_7 ;
	    
	    GPIO_Init(GPIOA, &GPIO_InitStruct);
	}
	
	void digitSel(int sel)
	{
	        uint16_t pinSel[] = {GPIO_Pin_9, GPIO_Pin_10, GPIO_Pin_11, GPIO_Pin_12};
	        int i = 0;
	        for(;i<4;++i)
	        {
	            if(sel == i)
	                GPIO_SetBits(GPIOA, pinSel[i]);
	            else
	                GPIO_ResetBits(GPIOA, pinSel[i]);
	        }
	}
	
	void digitDisp(int digit, int point)
	{
	    int node, i;
	    uint16_t pinSel[] = {GPIO_Pin_0, GPIO_Pin_1, GPIO_Pin_2, GPIO_Pin_3,GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_7};
	    int sel = 1<< 7;
	    
	    switch (digit)
	    {
	        case 0 : node = 0xFC; break; // 11111100
	    case 1 : node = 0x60; break; // 01100000
	    case 2 : node = 0xDA; break; // 11011010
	    case 3 : node = 0xF2; break; // 11110010
	    case 4 : node = 0x66; break; // 01100110
	    case 5 : node = 0xB6; break; // 10110110
	    case 6 : node = 0xBE; break; // 10111110
	    case 7 : node = 0xE0; break; // 11100000
	    case 8 : node = 0xFE; break; // 11111110
	    case 9 : node = 0xF6; break; // 11110110
	    default: node = 0x9E; break; // 10011110 error and display E to represent error
	   }
	     node |= (point != 0);
	     
	     for(i=0;i<8;i++)
	     {
	        if((node & sel) == 0)
	            GPIO_SetBits(GPIOA, pinSel[i]);
	        else
	            GPIO_ResetBits(GPIOA, pinSel[i]);
	        
	        sel >>= 1;
	     }
	}
	
	int value = 0;
	void TaskDisp(void *p_arg)
	{
	    int i, base, cnt = 7000;
	    while(1)
	    {
	        base = 1000;
	        for(i=0;i<4;i++)
	        {
	            digitDisp((value/base)%10, 0);
	            digitSel(i);
	            base /= 10;
	            while(cnt--);
	            cnt = 8000;
	        }
	    }
	}
	
	void TaskInc(void *p_arg)
	{
	    while(1)
	    {
	        value++;
	        value %= 10000;
	        OSTimeDly(100);
	    }
	}
	
	OS_STK TaskStk1[LED0STKSIZE];
	OS_STK TaskStk2[LED1STKSIZE];
	
	int main()
	{
	    GPIO_Config();    //initialize the gpio
	
	    OSInit();                    //initialize the os
	    OS_CPU_SysTickInit();    //initialze the system clock
	    
	    //create two task LED0 and LED
	    OSTaskCreate(TaskDisp, (void *)0, &TaskStk1[LED0STKSIZE - 1], 5);
	    OSTaskCreate(TaskInc, (void *)0, &TaskStk2[LED0STKSIZE - 1], 4);
	    OSStart();    //start the os
	    
	    return 0;
	}
	
载版后结果如下：
![](http://7xljx0.com1.z0.glb.clouddn.com/FullSizeRender%209.jpg?imageView/2/w/619/q/90)


### DHT11数据读取和显示
DHT11是一款有已校准数字信号输出的温湿度传感器。作为一个单总线的设备，输入和输出均为同一个引脚。

![](https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1463852359&di=1e805ba733ddff55f7a41ca7c77e96dd&src=http://static.oschina.net/uploads/img/201311/30123423_biVb.png)

对DHT11来说，数据的传输步骤如下：

![](http://bos.wenku.bdimg.com/v1/docconvert3615//wk/61dc75b95b9d627c8227692df18ac5dd/0.png?responseCacheControl=max-age%3D3888000&responseExpires=Wed%2C%2006%20Jul%202016%2001%3A43%3A13%20%2B0800&authorization=bce-auth-v1%2Ffa1126e91489401fa7cc85045ce7179e%2F2016-05-21T17%3A43%3A13Z%2F3600%2Fhost%2F6d083765d7a50c1c57422bf57cdde9f951dd72be6ecc4c5a280099533455eb81&x-bce-range=0-53702&token=35a8f921f8123e5efd876139301e2a8ff00ffa19384e84933dea121c9a2b8092&expire=2016-05-21T18:43:13Z)

stm32输出低电平至少18ms(只有此处为ms，其余均为μs)。

stm32输出高电平20~40μs

DHT11反馈低电平80μs

DHT11反馈高电平80μs

以上为双方握手，以下开始准备接受数据。数据总长40个bit，输入为大端输入，即高位的bit先进行传输。每个byte表示一个数值。按照接受顺序分别表示湿度整数，湿度小数，温度整数，温度小数，校验码。校验码为前方四个byte的和。

对于每个传输的bit，DHT11会首先输出50μs的低电平而后以输出高电平的时间决定每个bit的值。高电平持续时间为20~30μs的为bit 0，高电平持续时间为70μs的表示bit 1。

整个通信过程大约耗时4ms。

	#define MAX_TICS 100000
	#define DHT11_OK 0
	#define DHT11_NO_CONN 1
	#define DHT11_CS_ERROR 2
	#define DHT11_PORT GPIOB
	#define DHT11_PIN GPIO_Pin_0
	
	void Delay_us(int times){
	    unsigned int i;
	    for (i=0; i<times; i++){
	        unsigned int j;
	        for (j=0; j<0x3fff; j++){
	        }
	    }
	}

	void DHT11_Pin_OUT(){
	    // 调整DHT11 GPIO口为输出模式
	    GPIO_InitTypeDef GPIO_InitStructure;
	
	    GPIO_InitStructure.GPIO_Pin = DHT11_PIN;
	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	    GPIO_Init(DHT11_PORT, &GPIO_InitStructure);
	
	    DHT11_Set(1);
	}
	
	void ErrorState(int state){
	    // 使用死循环，显示错误码
	    while (1){
	        led_show(state);
	        Delay_us(4000);
	    }
	}		
	void DHT11_Set(int state){
	    // 设置DHT11 GPIO口的值
	    BitAction s;
	    if (state){
	        s = Bit_SET;
	    }else{
	        s = Bit_RESET;
	    }
	    GPIO_WriteBit(DHT11_PORT, DHT11_PIN, s);
	}
	

	void DHT11_Pin_IN(){
	    // 调整DHT11_GPIO口为输入模式
	    GPIO_InitTypeDef GPIO_InitStructure;
	
	    GPIO_InitStructure.GPIO_Pin = DHT11_PIN;
	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	    GPIO_Init(DHT11_PORT, &GPIO_InitStructure);
	
	    DHT11_Set(1);
	}
	
	uint8_t DHT11_Check(){
	    // 获取DHT11 GPIO口的数据，下方算式与调用函数等价
	    return (DHT11_PORT->IDR & DHT11_PIN)> 0;
	}
	
	void DHT11_Wait(int state, int place){
	    // 等待GPIO口变为state的值，超时自动自杀
	    int loopCnt = MAX_TICS;
	    while (DHT11_Check() != state){
	        if (loopCnt -- == 0){
	            ErrorState(1000 + state * 1000 + place);
	        }
	    }
	}
	
	void DHT11_Rst(){
	    // stm32端输出握手信号
	    DHT11_Pin_OUT();
	    DHT11_Set(0);
	    Delay_us(25000);
	    DHT11_Set(1);
	    Delay_us(40);
	    DHT11_Set(0);
	    // 转为接收模式准备读入DHT11的握手信号
	    DHT11_Pin_IN();
	}
	
	int val = 10;
	
	uint8_t DHT11_Read_Byte(){
	    // 读入一个Byte
	    int i, cnt;
	    uint8_t data = 0;
	    for (i=0; i<8; i++){
	        cnt = 0;
	        data <<= 1;
	        // 当前为低电平，等待高电平
	        DHT11_Wait(1, ++val);
	
	        // 计算高电平持续的时间
	        while (DHT11_Check() > 0){
	            Delay_us(1);
	            cnt++;
	        }
	        // 持续的足够久则为bit 1
	        data |= cnt > 5;
	    }
	    return data;
	}
	
	uint8_t DHT11_Read_Data(uint8_t *buf){
	    // 从DHT11内读取数据的函数
	    int i;
	    unsigned int cpu_sr;
	    // 为了关闭中断进入临界区
	    OS_ENTER_CRITICAL();
	    val = 10;
	    // 发送握手消息
	    DHT11_Rst();
	    // 如果给予了回复
	    if (DHT11_Check() == 0){
	        // 等待低电平过去
	        DHT11_Wait(1, 2);
	        // 等待高电平过去
	        DHT11_Wait(0, 3);
	        // 握手完成，开始读取40个bit
	        for (i=0; i<5; i++){
	            buf[i] = DHT11_Read_Byte();
	        }
	
	        // 重新将GPIO口置为输出模式
	        DHT11_Pin_OUT();
	        OS_EXIT_CRITICAL(); 
	
	        // 判断校验和是否满足要求
	        if (buf[0] + buf[1] + buf[2] + buf[3] == buf[4]){
	            return DHT11_OK;
	        }else{
	            return DHT11_CS_ERROR;
	        }
	    }else{
	        // 该分支表示没有收到回复
	        OS_EXIT_CRITICAL(); 
	        return DHT11_NO_CONN;
	    }
	}
	
	uint8_t DHT11_Humidity(uint8_t *buf){
	    // 返回湿度
	    return buf[0];
	}
	
	uint8_t DHT11_Temperature(uint8_t *buf){
	    // 返回温度
	    return buf[2];
	}

然后开一个任务直接调用`DHT11_Read_Data`函数进行读取即可。

	void task(void* pdata){
	    uint8_t buf[5];
	    int state;
	    memset(buf, 0, sizeof(buf));
	
	    while (1){
	        state = DHT11_Read_Data(buf);
	        switch(state){
	            case DHT11_CS_ERROR:
	                ledValue = 9002;
	                break;
	            case DHT11_NO_CONN:
	                ledValue = 9001;
	                break;
	            case DHT11_OK:
	                ledValue = DHT11_Temperature(buf);
	                break;
	        }
	        Delay_ms(1000);
	    }
	}
	
![](http://7xljx0.com1.z0.glb.clouddn.com/FullSizeRender%2010.jpg?imageView/2/w/619/q/90)

同样可以用上述任务实现对湿度的读取：

![](http://7xljx0.com1.z0.glb.clouddn.com/FullSizeRender%2019.jpg?imageView/2/w/619/q/90)

至此整个实验全部完成



## 参考资料：

[1] [uc/os工程的创建和移植](http://www.cnblogs.com/jackwang822/p/5514168.html)

[2] [Lab5 : uC/OS室温计 - 快来再点个灯](http://www.jianshu.com/p/d57c7f7eb118)

[3] [Humidity-stm32-I/dht11.c](https://github.com/tarasii/Humidity-stm32-I/blob/master/dht11.c)

[4] [Stm32程序控制DHT11](http://wenku.baidu.com/link?url=q45Du2opi0SljsMJGpJYJ8zrlNIjyEeLyYH-1aIrJG-s2PQAVEBpfGYKAtw5ChELNGy4s5YAIGhA470sRDyTWnZm6XwpKFWS2heoAJHjmWi)